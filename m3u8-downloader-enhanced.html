<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M3U8 增强版下载工具</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }

        .tool-switcher {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .tool-link {
            padding: 8px 16px;
            background: rgba(255,255,255,0.2);
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.3s;
        }

        .tool-link:hover {
            background: rgba(255,255,255,0.3);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            padding: 40px;
        }

        .input-section {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            border: 2px solid #e9ecef;
        }

        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .input-field {
            flex: 1;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .input-field:focus {
            outline: none;
            border-color: #667eea;
        }

        .file-input {
            display: none;
        }

        .file-label {
            padding: 15px 30px;
            background: #28a745;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .file-label:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .format-selector {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .format-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .format-option input[type="radio"] {
            width: 20px;
            height: 20px;
        }

        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            text-align: center;
            border: 2px solid #e9ecef;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #6c757d;
            font-size: 0.9em;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        .log-section {
            background: #000;
            color: #00ff00;
            padding: 20px;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .encryption-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .encryption-info h3 {
            color: #856404;
            margin-bottom: 15px;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-info {
            background: #cce7ff;
            color: #004085;
            border: 1px solid #b8daff;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .hidden {
            display: none;
        }

        .ffmpeg-section {
            background: #f1f3f4;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }

        .ffmpeg-command {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin: 10px 0;
            overflow-x: auto;
        }

        .method-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 20px;
            background: #e9ecef;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab.active {
            background: #667eea;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .advanced-options {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            border: 2px solid #e9ecef;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .option-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .option-group label {
            font-weight: 600;
            color: #495057;
        }

        .option-group select,
        .option-group input {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
        }

        .option-group select:focus,
        .option-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-loading {
            background: #fff3cd;
            color: #856404;
        }

        .status-ready {
            background: #d4edda;
            color: #155724;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        @media (max-width: 768px) {
            .input-group {
                flex-direction: column;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
            
            .options-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="tool-switcher">
                <a href="video-detector-enhanced.html" class="tool-link">🎬 视频检测</a>
                <a href="video-test-page.html" class="tool-link">🧪 测试页面</a>
                <a href="m3u8-encrypted-downloader.sh" class="tool-link">⚡ 命令行</a>
            </div>
            <h1>🎬 M3U8 增强版下载工具</h1>
            <p>支持加密视频、本地文件、多种下载方式</p>
        </div>

        <div class="main-content">
            <!-- 方法选择标签 -->
            <div class="method-tabs">
                <button class="tab active" onclick="switchTab('browser')">🌐 浏览器下载</button>
                <button class="tab" onclick="switchTab('ffmpeg')">⚡ FFmpeg 下载</button>
                <button class="tab" onclick="switchTab('local')">📁 本地文件</button>
            </div>

            <!-- 浏览器下载方式 -->
            <div class="tab-content active" id="browser-tab">
                <div class="input-section">
                    <h3>📥 浏览器下载方式</h3>
                    <div class="input-group">
                        <input type="text" class="input-field" id="m3u8Url" placeholder="请输入 M3U8 链接地址...">
                        <button class="btn btn-primary" onclick="parseM3U8()">🔍 解析下载</button>
                    </div>
                    
                    <div class="format-selector">
                        <label class="format-option">
                            <input type="radio" name="format" value="mp4" checked>
                            <span>MP4 格式</span>
                        </label>
                        <label class="format-option">
                            <input type="radio" name="format" value="ts">
                            <span>TS 格式</span>
                        </label>
                        <label class="format-option">
                            <input type="radio" name="format" value="m3u8">
                            <span>M3U8 格式</span>
                        </label>
                    </div>

                    <div class="controls">
                        <button class="btn btn-secondary" onclick="retryFailedSegments()">🔄 重试失败片段</button>
                        <button class="btn btn-success" onclick="forceDownload()">⚡ 强制下载</button>
                        <button class="btn btn-danger" onclick="clearAll()">🗑️ 清空重置</button>
                    </div>
                </div>

                <!-- 加密信息显示 -->
                <div class="encryption-info hidden" id="encryptionInfo">
                    <h3>🔐 检测到加密视频</h3>
                    <p>此视频使用了加密保护，浏览器下载可能无法正常处理。</p>
                    <p><strong>建议</strong>：切换到 "FFmpeg 下载" 方式获得更好的兼容性。</p>
                </div>
            </div>

            <!-- FFmpeg 下载方式 -->
            <div class="tab-content" id="ffmpeg-tab">
                <div class="ffmpeg-section">
                    <h3>⚡ FFmpeg 专业下载</h3>
                    <p>使用 FFmpeg 可以处理加密的 M3U8 视频，支持更多格式和选项。</p>
                    
                    <div class="input-group">
                        <input type="text" class="input-field" id="ffmpegUrl" placeholder="请输入 M3U8 链接地址...">
                        <button class="btn btn-primary" onclick="generateFFmpegCommand()">🔧 生成命令</button>
                    </div>

                    <div class="format-selector">
                        <label class="format-option">
                            <input type="radio" name="ffmpeg-format" value="mp4" checked>
                            <span>MP4 格式</span>
                        </label>
                        <label class="format-option">
                            <input type="radio" name="ffmpeg-format" value="mkv">
                            <span>MKV 格式</span>
                        </label>
                        <label class="format-option">
                            <input type="radio" name="ffmpeg-format" value="ts">
                            <span>TS 格式</span>
                        </label>
                    </div>

                    <div class="controls">
                        <button class="btn btn-warning" onclick="copyFFmpegCommand()">📋 复制命令</button>
                        <button class="btn btn-success" onclick="executeFFmpeg()">⏳ 初始化中...</button>
                        <button class="btn btn-info" onclick="showAdvancedOptions()">⚙️ 高级选项</button>
                    </div>

                    <div class="ffmpeg-command hidden" id="ffmpegCommand"></div>
                    
                    <!-- 高级选项面板 -->
                    <div class="advanced-options hidden" id="advancedOptions">
                        <h4>🔧 高级处理选项</h4>
                        <div class="options-grid">
                            <div class="option-group">
                                <label>视频编码器：</label>
                                <select id="videoCodec">
                                    <option value="copy">直接复制 (最快)</option>
                                    <option value="libx264">H.264 (通用)</option>
                                    <option value="libx265">H.265 (高压缩)</option>
                                </select>
                            </div>
                            <div class="option-group">
                                <label>视频比特率：</label>
                                <input type="text" id="videoBitrate" placeholder="如: 2000k">
                            </div>
                            <div class="option-group">
                                <label>分辨率：</label>
                                <select id="resolution">
                                    <option value="">保持原始</option>
                                    <option value="1920x1080">1080p</option>
                                    <option value="1280x720">720p</option>
                                    <option value="854x480">480p</option>
                                </select>
                            </div>
                            <div class="option-group">
                                <label>帧率：</label>
                                <input type="text" id="fps" placeholder="如: 30">
                            </div>
                            <div class="option-group">
                                <label>音频比特率：</label>
                                <input type="text" id="audioBitrate" placeholder="如: 128k">
                            </div>
                        </div>
                        <div class="controls">
                            <button class="btn btn-primary" onclick="executeAdvancedFFmpegFromUI()">🚀 高级处理</button>
                            <button class="btn btn-secondary" onclick="hideAdvancedOptions()">❌ 关闭</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 本地文件方式 -->
            <div class="tab-content" id="local-tab">
                <div class="input-section">
                    <h3>📁 本地 M3U8 文件</h3>
                    <p>选择已下载的 M3U8 文件进行处理</p>
                    
                    <div class="input-group">
                        <input type="file" class="file-input" id="localFile" accept=".m3u8,.m3u" onchange="handleLocalFile()">
                        <label for="localFile" class="file-label">📂 选择本地文件</label>
                        <button class="btn btn-primary" onclick="parseLocalM3U8()">🔍 解析文件</button>
                    </div>

                    <div class="controls">
                        <button class="btn btn-warning" onclick="generateLocalFFmpegCommand()">⚡ 生成 FFmpeg 命令</button>
                        <button class="btn btn-success" onclick="processLocalFile()">🔧 处理文件</button>
                    </div>

                    <div class="alert alert-info">
                        <strong>提示：</strong>本地文件方式适用于已经下载的 M3U8 文件，可以生成对应的 FFmpeg 命令进行处理。
                    </div>
                </div>
            </div>

            <!-- 统计信息 -->
            <div class="stats-grid hidden" id="statsSection">
                <div class="stat-card">
                    <div class="stat-number" id="totalSegments">0</div>
                    <div class="stat-label">总片段数</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="downloadedSegments">0</div>
                    <div class="stat-label">已下载</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="failedSegments">0</div>
                    <div class="stat-label">下载失败</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="downloadProgress">0%</div>
                    <div class="stat-label">下载进度</div>
                </div>
            </div>

            <!-- 进度条 -->
            <div class="progress-bar hidden" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>

            <!-- 日志输出 -->
            <div class="log-section hidden" id="logSection">
                <div id="logOutput"></div>
            </div>
        </div>
    </div>

    <!-- FFmpeg WebAssembly 支持 -->
    <script src="https://unpkg.com/@ffmpeg/util@0.12.1/dist/umd/index.js"></script>
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/umd/index.js"></script>
    
    <script>
        // 全局变量
        let segments = [];
        let downloadedSegments = [];
        let failedSegments = [];
        let isDownloading = false;
        let encryptionKey = null;
        let encryptionIV = null;
        let baseUrl = '';
        let currentLocalFile = null;
        
        // FFmpeg WebAssembly 相关
        let ffmpeg = null;
        let ffmpegLoaded = false;
        let isFFmpegProcessing = false;

        // 切换标签
        function switchTab(tabName) {
            // 隐藏所有标签内容
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 移除所有标签的激活状态
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 显示选中的标签内容
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // 激活选中的标签
            event.target.classList.add('active');
            
            // 如果切换到 FFmpeg 标签，初始化 FFmpeg
            if (tabName === 'ffmpeg' && !ffmpegLoaded) {
                initFFmpeg();
            }
        }

        // 初始化 FFmpeg WebAssembly
        async function initFFmpeg() {
            if (ffmpegLoaded || isFFmpegProcessing) return;
            
            try {
                log('正在初始化 FFmpeg WebAssembly...', 'info');
                showAlert('正在加载 FFmpeg，请稍候...', 'info');
                
                const { FFmpeg } = FFmpegWASM;
                const { toBlobURL } = FFmpegUtil;
                
                ffmpeg = new FFmpeg();
                
                // 监听进度和日志
                ffmpeg.on('log', ({ message }) => {
                    log(`FFmpeg: ${message}`, 'info');
                });
                
                ffmpeg.on('progress', ({ progress, time }) => {
                    const percent = Math.round(progress * 100);
                    log(`FFmpeg 进度: ${percent}% (${time}s)`, 'info');
                    updateFFmpegProgress(percent);
                });
                
                // 加载 FFmpeg 核心文件
                const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd';
                await ffmpeg.load({
                    coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
                    wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
                });
                
                ffmpegLoaded = true;
                log('FFmpeg WebAssembly 初始化成功！', 'success');
                showAlert('FFmpeg 加载完成！现在可以直接在网页执行视频处理', 'success');
                
                // 更新状态和按钮
                updateFFmpegStatus('ready', '✅ 已就绪');
                updateFFmpegButtons();
                
            } catch (error) {
                log(`FFmpeg 初始化失败: ${error.message}`, 'error');
                showAlert(`FFmpeg 初始化失败: ${error.message}`, 'error');
                updateFFmpegStatus('error', '❌ 初始化失败');
            }
        }

        // 更新 FFmpeg 进度显示
        function updateFFmpegProgress(percent) {
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            
            progressBar.classList.remove('hidden');
            progressFill.style.width = percent + '%';
            
            // 更新进度文本
            const progressText = document.getElementById('downloadProgress');
            if (progressText) {
                progressText.textContent = percent + '%';
            }
        }

        // 更新 FFmpeg 按钮状态
        function updateFFmpegButtons() {
            const executeBtn = document.querySelector('[onclick="executeFFmpeg()"]');
            if (executeBtn) {
                if (ffmpegLoaded) {
                    executeBtn.textContent = '▶️ 网页端执行';
                    executeBtn.classList.remove('btn-secondary');
                    executeBtn.classList.add('btn-success');
                } else {
                    executeBtn.textContent = '⏳ 加载中...';
                    executeBtn.classList.add('btn-secondary');
                    executeBtn.classList.remove('btn-success');
                }
            }
        }

        // 日志输出
        function log(message, type = 'info') {
            const logOutput = document.getElementById('logOutput');
            const logSection = document.getElementById('logSection');
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'error' ? '#ff6b6b' : type === 'success' ? '#51cf66' : type === 'warning' ? '#ffd93d' : '#00ff00';
            
            logOutput.innerHTML += `<div style="color: ${color};">[${timestamp}] ${message}</div>`;
            logSection.scrollTop = logSection.scrollHeight;
            logSection.classList.remove('hidden');
        }

        // 显示提示信息
        function showAlert(message, type = 'info') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.innerHTML = message;
            
            const mainContent = document.querySelector('.main-content');
            mainContent.insertBefore(alertDiv, mainContent.firstChild);
            
            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }

        // 解析 M3U8 文件
        async function parseM3U8() {
            const url = document.getElementById('m3u8Url').value.trim();
            if (!url) {
                showAlert('请输入 M3U8 链接地址', 'error');
                return;
            }

            if (!url.includes('.m3u8')) {
                showAlert('请输入有效的 M3U8 链接', 'error');
                return;
            }

            log('开始解析 M3U8 文件...');
            
            try {
                baseUrl = url.substring(0, url.lastIndexOf('/') + 1);
                
                // 尝试使用不同的方法获取M3U8文件
                let m3u8Content;
                let fetchSuccess = false;
                
                try {
                    // 方法1: 直接fetch
                    const response = await fetch(url, {
                        mode: 'cors',
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                        }
                    });
                    
                    if (response.ok) {
                        m3u8Content = await response.text();
                        fetchSuccess = true;
                        log('M3U8 文件解析成功 (直接获取)');
                    } else {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                } catch (corsError) {
                    log(`直接获取失败: ${corsError.message}`, 'warning');
                    
                    // 方法2: 尝试使用代理
                    try {
                        const proxyUrl = `https://cors-anywhere.herokuapp.com/${url}`;
                        const proxyResponse = await fetch(proxyUrl);
                        
                        if (proxyResponse.ok) {
                            m3u8Content = await proxyResponse.text();
                            fetchSuccess = true;
                            log('M3U8 文件解析成功 (代理获取)');
                        } else {
                            throw new Error(`代理请求失败: ${proxyResponse.status}`);
                        }
                    } catch (proxyError) {
                        log(`代理获取失败: ${proxyError.message}`, 'warning');
                        
                        // 方法3: 显示手动输入选项
                        showManualInputOption(url);
                        return;
                    }
                }
                
                if (fetchSuccess && m3u8Content) {
                    // 检查是否有加密
                    checkEncryption(m3u8Content);
                    
                    // 解析片段
                    parseSegments(m3u8Content);
                } else {
                    throw new Error('无法获取M3U8文件内容');
                }
                
            } catch (error) {
                log(`解析失败: ${error.message}`, 'error');
                showAlert(`解析失败: ${error.message}`, 'error');
                
                // 显示 FFmpeg 建议
                showFFmpegSuggestion(url);
            }
        }

        // 检查加密
        function checkEncryption(content) {
            const lines = content.split('\\n');
            const keyLine = lines.find(line => line.includes('#EXT-X-KEY:'));
            
            if (keyLine) {
                log('检测到加密视频', 'warning');
                
                // 解析加密信息
                const method = keyLine.match(/METHOD=([^,]+)/)?.[1];
                const keyUri = keyLine.match(/URI="([^"]+)"/)?.[1];
                const iv = keyLine.match(/IV=([^,\\s]+)/)?.[1];
                
                if (method === 'AES-128') {
                    log(`加密方式: ${method}`, 'info');
                    log(`密钥地址: ${keyUri}`, 'info');
                    if (iv) log(`初始向量: ${iv}`, 'info');
                    
                    // 显示加密信息
                    document.getElementById('encryptionInfo').classList.remove('hidden');
                    
                    // 尝试获取密钥
                    fetchEncryptionKey(keyUri, iv);
                }
            } else {
                log('未检测到加密，使用标准下载方式', 'success');
            }
        }

        // 获取加密密钥
        async function fetchEncryptionKey(keyUri, iv) {
            try {
                const keyUrl = keyUri.startsWith('http') ? keyUri : baseUrl + keyUri;
                const response = await fetch(keyUrl);
                
                if (response.ok) {
                    const keyData = await response.arrayBuffer();
                    encryptionKey = new Uint8Array(keyData);
                    encryptionIV = iv;
                    log('加密密钥获取成功', 'success');
                } else {
                    log('加密密钥获取失败，可能需要特殊处理', 'warning');
                }
            } catch (error) {
                log(`密钥获取失败: ${error.message}`, 'error');
            }
        }

        // 解析视频片段
        function parseSegments(content) {
            segments = [];
            const lines = content.split('\\n');
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line && !line.startsWith('#') && (line.includes('.ts') || line.includes('.m4s'))) {
                    const segmentUrl = line.startsWith('http') ? line : baseUrl + line;
                    segments.push({
                        url: segmentUrl,
                        index: segments.length,
                        status: 'pending',
                        data: null
                    });
                }
            }
            
            if (segments.length === 0) {
                showAlert('未找到视频片段，请检查 M3U8 文件格式', 'error');
                return;
            }
            
            log(`找到 ${segments.length} 个视频片段`);
            showAlert(`解析成功！找到 ${segments.length} 个视频片段`, 'success');
            
            // 显示统计信息
            document.getElementById('statsSection').classList.remove('hidden');
            updateStats();
            
            // 开始下载
            startDownload();
        }

        // 更新统计信息
        function updateStats() {
            const total = segments.length;
            const downloaded = segments.filter(s => s.status === 'success').length;
            const failed = segments.filter(s => s.status === 'error').length;
            const progress = total > 0 ? Math.round((downloaded / total) * 100) : 0;
            
            document.getElementById('totalSegments').textContent = total;
            document.getElementById('downloadedSegments').textContent = downloaded;
            document.getElementById('failedSegments').textContent = failed;
            document.getElementById('downloadProgress').textContent = progress + '%';
            
            // 更新进度条
            document.getElementById('progressBar').classList.remove('hidden');
            document.getElementById('progressFill').style.width = progress + '%';
        }

        // 开始下载
        async function startDownload() {
            if (isDownloading) return;
            
            isDownloading = true;
            log('开始下载视频片段...');
            
            // 并发下载
            const concurrency = 3; // 降低并发数以避免服务器限制
            
            for (let i = 0; i < segments.length; i += concurrency) {
                const batch = segments.slice(i, i + concurrency);
                await Promise.all(batch.map(segment => downloadSegment(segment)));
                
                // 更新统计
                updateStats();
                
                // 短暂延迟避免服务器限制
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            isDownloading = false;
            log('下载完成');
            
            // 检查结果
            const failed = segments.filter(s => s.status === 'error').length;
            if (failed > 0) {
                showAlert(`下载完成，但有 ${failed} 个片段失败`, 'warning');
            } else {
                showAlert('所有片段下载成功！', 'success');
                // 自动合并
                await mergeSegments();
            }
        }

        // 下载单个片段
        async function downloadSegment(segment) {
            try {
                const response = await fetch(segment.url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                let data = await response.arrayBuffer();
                
                // 如果有加密，尝试解密
                if (encryptionKey && encryptionIV) {
                    data = await decryptSegment(data, encryptionKey, encryptionIV);
                }
                
                segment.data = data;
                segment.status = 'success';
                
                log(`片段 ${segment.index + 1} 下载成功`);
                
            } catch (error) {
                segment.status = 'error';
                log(`片段 ${segment.index + 1} 下载失败: ${error.message}`, 'error');
            }
        }

        // AES-128 解密（简化版）
        async function decryptSegment(data, key, iv) {
            try {
                // 这里应该实现 AES-128 解密
                // 由于 Web Crypto API 的限制，实际项目中可能需要使用专门的加密库
                log('尝试解密片段...', 'info');
                
                // 暂时返回原始数据
                return data;
            } catch (error) {
                log(`解密失败: ${error.message}`, 'error');
                return data;
            }
        }

        // 合并片段
        async function mergeSegments() {
            const format = document.querySelector('input[name="format"]:checked').value;
            const successSegments = segments.filter(s => s.status === 'success' && s.data);
            
            if (successSegments.length === 0) {
                showAlert('没有可用的视频片段', 'error');
                return;
            }
            
            log(`开始合并 ${successSegments.length} 个片段...`);
            
            // 计算总大小
            const totalSize = successSegments.reduce((sum, segment) => sum + segment.data.byteLength, 0);
            
            // 创建合并后的数据
            const mergedData = new Uint8Array(totalSize);
            let offset = 0;
            
            for (const segment of successSegments) {
                mergedData.set(new Uint8Array(segment.data), offset);
                offset += segment.data.byteLength;
            }
            
            // 下载文件
            const blob = new Blob([mergedData], { 
                type: format === 'mp4' ? 'video/mp4' : 'video/mp2t' 
            });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `video_${Date.now()}.${format}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            log(`${format.toUpperCase()} 视频下载完成`);
            showAlert(`视频下载完成！`, 'success');
        }

        // 生成 FFmpeg 命令
        function generateFFmpegCommand() {
            const url = document.getElementById('ffmpegUrl').value.trim();
            if (!url) {
                showAlert('请输入 M3U8 链接地址', 'error');
                return;
            }
            
            const format = document.querySelector('input[name="ffmpeg-format"]:checked').value;
            const timestamp = Date.now();
            
            const command = `ffmpeg -protocol_whitelist file,http,https,tcp,tls,crypto -i "${url}" -c copy "video_${timestamp}.${format}" -y`;
            
            document.getElementById('ffmpegCommand').textContent = command;
            document.getElementById('ffmpegCommand').classList.remove('hidden');
            
            log('FFmpeg 命令生成成功', 'success');
            showAlert('FFmpeg 命令已生成，请复制到终端执行', 'success');
        }

        // 复制 FFmpeg 命令
        function copyFFmpegCommand() {
            const command = document.getElementById('ffmpegCommand').textContent;
            if (!command) {
                showAlert('请先生成 FFmpeg 命令', 'error');
                return;
            }
            
            navigator.clipboard.writeText(command).then(() => {
                showAlert('命令已复制到剪贴板', 'success');
            }).catch(() => {
                showAlert('复制失败，请手动复制', 'error');
            });
        }

        // 执行 FFmpeg（WebAssembly 版本）
        async function executeFFmpeg() {
            const url = document.getElementById('ffmpegUrl').value.trim();
            if (!url) {
                showAlert('请输入 M3U8 链接地址', 'error');
                return;
            }
            
            if (!ffmpegLoaded) {
                showAlert('FFmpeg 还未加载完成，请稍候...', 'warning');
                await initFFmpeg();
                return;
            }
            
            if (isFFmpegProcessing) {
                showAlert('FFmpeg 正在处理中，请勿重复执行', 'warning');
                return;
            }
            
            try {
                isFFmpegProcessing = true;
                log('开始使用 FFmpeg WebAssembly 处理视频...', 'info');
                showAlert('开始处理视频，请稍候...', 'info');
                
                const format = document.querySelector('input[name="ffmpeg-format"]:checked').value;
                const timestamp = Date.now();
                const outputFileName = `video_${timestamp}.${format}`;
                
                // 显示进度
                document.getElementById('progressBar').classList.remove('hidden');
                document.getElementById('statsSection').classList.remove('hidden');
                
                // 执行 FFmpeg 命令
                await ffmpeg.exec([
                    '-protocol_whitelist', 'file,http,https,tcp,tls,crypto',
                    '-i', url,
                    '-c', 'copy',
                    '-y',
                    outputFileName
                ]);
                
                // 获取输出文件
                const data = await ffmpeg.readFile(outputFileName);
                
                // 下载文件
                const blob = new Blob([data], { 
                    type: format === 'mp4' ? 'video/mp4' : format === 'mkv' ? 'video/x-matroska' : 'video/mp2t' 
                });
                const downloadUrl = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = outputFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(downloadUrl);
                
                // 清理 FFmpeg 文件系统
                await ffmpeg.deleteFile(outputFileName);
                
                log('视频处理完成！', 'success');
                showAlert('视频处理完成并已开始下载！', 'success');
                
            } catch (error) {
                log(`FFmpeg 处理失败: ${error.message}`, 'error');
                showAlert(`视频处理失败: ${error.message}`, 'error');
                
                // 如果 WebAssembly 失败，回退到生成命令
                log('回退到生成命令模式...', 'info');
                generateFFmpegCommand();
                showAlert('WebAssembly 处理失败，已生成命令供终端使用', 'warning');
                
            } finally {
                isFFmpegProcessing = false;
                document.getElementById('progressBar').classList.add('hidden');
            }
        }

        // 高级 FFmpeg 处理（支持更多选项）
        async function executeAdvancedFFmpeg(inputUrl, options = {}) {
            if (!ffmpegLoaded) {
                await initFFmpeg();
            }
            
            try {
                isFFmpegProcessing = true;
                log('开始高级 FFmpeg 处理...', 'info');
                
                const {
                    format = 'mp4',
                    videoBitrate = null,
                    audioBitrate = null,
                    resolution = null,
                    fps = null,
                    codec = 'copy'
                } = options;
                
                const timestamp = Date.now();
                const outputFileName = `video_${timestamp}.${format}`;
                
                // 构建 FFmpeg 参数
                const args = [
                    '-protocol_whitelist', 'file,http,https,tcp,tls,crypto',
                    '-i', inputUrl
                ];
                
                // 添加视频编码选项
                if (codec !== 'copy') {
                    args.push('-c:v', codec);
                    if (videoBitrate) args.push('-b:v', videoBitrate);
                    if (resolution) args.push('-s', resolution);
                    if (fps) args.push('-r', fps);
                } else {
                    args.push('-c', 'copy');
                }
                
                // 添加音频选项
                if (audioBitrate) {
                    args.push('-c:a', 'aac');
                    args.push('-b:a', audioBitrate);
                }
                
                args.push('-y', outputFileName);
                
                log(`FFmpeg 参数: ${args.join(' ')}`, 'info');
                
                // 执行命令
                await ffmpeg.exec(args);
                
                // 获取和下载文件
                const data = await ffmpeg.readFile(outputFileName);
                const blob = new Blob([data], { 
                    type: format === 'mp4' ? 'video/mp4' : format === 'mkv' ? 'video/x-matroska' : 'video/mp2t' 
                });
                
                const downloadUrl = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = outputFileName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(downloadUrl);
                
                await ffmpeg.deleteFile(outputFileName);
                
                log('高级 FFmpeg 处理完成！', 'success');
                return outputFileName;
                
            } catch (error) {
                log(`高级 FFmpeg 处理失败: ${error.message}`, 'error');
                throw error;
            } finally {
                isFFmpegProcessing = false;
            }
        }

        // 显示高级选项
        function showAdvancedOptions() {
            document.getElementById('advancedOptions').classList.remove('hidden');
        }

        // 隐藏高级选项
        function hideAdvancedOptions() {
            document.getElementById('advancedOptions').classList.add('hidden');
        }

        // 从UI执行高级FFmpeg处理
        async function executeAdvancedFFmpegFromUI() {
            const url = document.getElementById('ffmpegUrl').value.trim();
            if (!url) {
                showAlert('请输入 M3U8 链接地址', 'error');
                return;
            }

            const format = document.querySelector('input[name="ffmpeg-format"]:checked').value;
            const options = {
                format: format,
                codec: document.getElementById('videoCodec').value,
                videoBitrate: document.getElementById('videoBitrate').value || null,
                audioBitrate: document.getElementById('audioBitrate').value || null,
                resolution: document.getElementById('resolution').value || null,
                fps: document.getElementById('fps').value || null
            };

            try {
                showAlert('开始高级处理，请稍候...', 'info');
                await executeAdvancedFFmpeg(url, options);
                showAlert('高级处理完成！', 'success');
            } catch (error) {
                showAlert(`高级处理失败: ${error.message}`, 'error');
            }
        }

        // 页面加载时初始化
        document.addEventListener('DOMContentLoaded', function() {
            // 检查浏览器支持
            if (!window.SharedArrayBuffer) {
                showAlert('您的浏览器不支持 SharedArrayBuffer，WebAssembly FFmpeg 可能无法正常工作。建议使用最新版本的 Chrome 或 Firefox。', 'warning');
            }
            
            // 添加 FFmpeg 状态指示器
            const ffmpegSection = document.querySelector('.ffmpeg-section h3');
            if (ffmpegSection) {
                ffmpegSection.innerHTML = '⚡ FFmpeg 专业下载 <span class="status-indicator status-loading" id="ffmpegStatus">⏳ 未初始化</span>';
            }
        });

        // 更新 FFmpeg 状态
        function updateFFmpegStatus(status, message) {
            const statusEl = document.getElementById('ffmpegStatus');
            if (statusEl) {
                statusEl.className = `status-indicator status-${status}`;
                statusEl.textContent = message;
            }
        }

        // 处理本地文件
        function handleLocalFile() {
            const fileInput = document.getElementById('localFile');
            const file = fileInput.files[0];
            
            if (file) {
                currentLocalFile = file;
                log(`选择了本地文件: ${file.name}`, 'info');
                showAlert(`已选择文件: ${file.name}`, 'success');
            }
        }

        // 解析本地 M3U8 文件
        function parseLocalM3U8() {
            if (!currentLocalFile) {
                showAlert('请先选择本地文件', 'error');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                log('本地文件读取成功', 'success');
                
                // 分析文件内容
                analyzeLocalM3U8(content);
            };
            
            reader.readAsText(currentLocalFile);
        }

        // 分析本地 M3U8 文件
        function analyzeLocalM3U8(content) {
            const lines = content.split('\\n');
            let segmentCount = 0;
            let hasEncryption = false;
            let totalDuration = 0;
            
            for (const line of lines) {
                if (line.includes('.ts') || line.includes('.m4s')) {
                    segmentCount++;
                } else if (line.includes('#EXT-X-KEY:')) {
                    hasEncryption = true;
                } else if (line.includes('#EXTINF:')) {
                    const duration = parseFloat(line.match(/#EXTINF:([\\d.]+)/)?.[1] || 0);
                    totalDuration += duration;
                }
            }
            
            log(`文件分析完成:`);
            log(`- 片段数量: ${segmentCount}`);
            log(`- 总时长: ${Math.round(totalDuration)} 秒`);
            log(`- 是否加密: ${hasEncryption ? '是' : '否'}`);
            
            if (hasEncryption) {
                showAlert('检测到加密视频，建议使用 FFmpeg 方式处理', 'warning');
            }
        }

        // 生成本地文件 FFmpeg 命令
        function generateLocalFFmpegCommand() {
            if (!currentLocalFile) {
                showAlert('请先选择本地文件', 'error');
                return;
            }
            
            const format = 'mp4';
            const timestamp = Date.now();
            const filePath = currentLocalFile.name;
            
            const command = `ffmpeg -protocol_whitelist file,http,https,tcp,tls,crypto -i "${filePath}" -c copy "video_${timestamp}.${format}" -y`;
            
            document.getElementById('ffmpegCommand').textContent = command;
            document.getElementById('ffmpegCommand').classList.remove('hidden');
            
            log('本地文件 FFmpeg 命令生成成功', 'success');
            showAlert('FFmpeg 命令已生成，请在文件所在目录的终端执行', 'success');
        }

        // 处理本地文件
        // 显示手动输入选项
        function showManualInputOption(url) {
            const manualInputHtml = `
                <div class="alert alert-warning">
                    <h4>🔒 无法直接获取M3U8文件</h4>
                    <p>由于CORS限制，无法直接解析M3U8文件。请选择以下方式之一：</p>
                    <div style="margin-top: 15px;">
                        <button class="btn btn-primary" onclick="showManualPasteArea('${url}')">手动粘贴M3U8内容</button>
                        <button class="btn btn-success" onclick="switchToFFmpeg('${url}')">使用FFmpeg下载</button>
                        <button class="btn btn-info" onclick="showCorsHelp()">了解CORS问题</button>
                    </div>
                </div>
            `;
            
            const mainContent = document.querySelector('.main-content');
            const alertDiv = document.createElement('div');
            alertDiv.innerHTML = manualInputHtml;
            mainContent.appendChild(alertDiv);
            
            setTimeout(() => {
                alertDiv.remove();
            }, 30000);
        }

        // 显示手动粘贴区域
        function showManualPasteArea(url) {
            const pasteAreaHtml = `
                <div class="input-section" id="manualPasteArea">
                    <h3>📋 手动粘贴M3U8内容</h3>
                    <p>请手动访问M3U8链接，复制内容并粘贴到下方：</p>
                    <div style="margin-bottom: 15px;">
                        <strong>M3U8链接:</strong> <a href="${url}" target="_blank">${url}</a>
                    </div>
                    <textarea id="manualM3u8Content" placeholder="请粘贴M3U8文件内容..." style="width: 100%; height: 200px; padding: 10px; border: 2px solid #dee2e6; border-radius: 8px; font-family: monospace; font-size: 14px;"></textarea>
                    <div style="margin-top: 15px;">
                        <button class="btn btn-primary" onclick="parseManualContent('${url}')">解析内容</button>
                        <button class="btn btn-secondary" onclick="document.getElementById('manualPasteArea').remove()">取消</button>
                    </div>
                </div>
            `;
            
            const mainContent = document.querySelector('.main-content');
            const existingArea = document.getElementById('manualPasteArea');
            if (existingArea) {
                existingArea.remove();
            }
            
            const pasteDiv = document.createElement('div');
            pasteDiv.innerHTML = pasteAreaHtml;
            mainContent.appendChild(pasteDiv);
        }

        // 解析手动输入的内容
        function parseManualContent(url) {
            const content = document.getElementById('manualM3u8Content').value.trim();
            if (!content) {
                showAlert('请粘贴M3U8文件内容', 'error');
                return;
            }

            try {
                baseUrl = url.substring(0, url.lastIndexOf('/') + 1);
                log('开始解析手动输入的M3U8内容...');
                
                // 检查是否有加密
                checkEncryption(content);
                
                // 解析片段
                parseSegments(content);
                
                // 移除手动输入区域
                document.getElementById('manualPasteArea').remove();
                
                log('手动输入的M3U8内容解析成功');
                showAlert('M3U8内容解析成功！', 'success');
                
            } catch (error) {
                log(`手动解析失败: ${error.message}`, 'error');
                showAlert(`解析失败: ${error.message}`, 'error');
            }
        }

        // 显示CORS帮助信息
        function showCorsHelp() {
            const helpHtml = `
                <div class="alert alert-info">
                    <h4>🔒 关于CORS限制</h4>
                    <p><strong>CORS (跨域资源共享)</strong> 是浏览器的安全机制，防止网页访问其他域名的资源。</p>
                    <h5>解决方案：</h5>
                    <ul>
                        <li><strong>使用FFmpeg:</strong> 最推荐的方式，绕过所有限制</li>
                        <li><strong>手动粘贴:</strong> 直接访问M3U8链接，复制内容粘贴</li>
                        <li><strong>浏览器插件:</strong> 安装CORS插件临时禁用限制</li>
                        <li><strong>命令行工具:</strong> 使用我们提供的shell脚本</li>
                    </ul>
                    <div style="margin-top: 15px;">
                        <button class="btn btn-primary" onclick="this.parentElement.parentElement.remove()">我知道了</button>
                    </div>
                </div>
            `;
            
            const mainContent = document.querySelector('.main-content');
            const helpDiv = document.createElement('div');
            helpDiv.innerHTML = helpHtml;
            mainContent.appendChild(helpDiv);
        }

        function processLocalFile() {
            generateLocalFFmpegCommand();
        }

        // 显示 FFmpeg 建议
        function showFFmpegSuggestion(url) {
            const suggestion = `
                <div class="alert alert-info">
                    <h4>💡 建议使用 FFmpeg 下载</h4>
                    <p>检测到此视频可能使用了加密或特殊格式，建议切换到 "FFmpeg 下载" 方式。</p>
                    <button class="btn btn-primary" onclick="switchToFFmpeg('${url}')">切换到 FFmpeg</button>
                </div>
            `;
            
            const mainContent = document.querySelector('.main-content');
            const alertDiv = document.createElement('div');
            alertDiv.innerHTML = suggestion;
            mainContent.insertBefore(alertDiv, mainContent.firstChild);
        }

        // 切换到 FFmpeg 方式
        function switchToFFmpeg(url) {
            switchTab('ffmpeg');
            document.getElementById('ffmpegUrl').value = url;
            generateFFmpegCommand();
        }

        // 重试失败片段
        async function retryFailedSegments() {
            const failed = segments.filter(s => s.status === 'error');
            if (failed.length === 0) {
                showAlert('没有失败的片段需要重试', 'info');
                return;
            }
            
            log(`开始重试 ${failed.length} 个失败片段...`);
            
            for (const segment of failed) {
                await downloadSegment(segment);
                updateStats();
            }
            
            showAlert('重试完成', 'success');
        }

        // 强制下载
        async function forceDownload() {
            await mergeSegments();
        }

        // 清空所有数据
        function clearAll() {
            segments = [];
            downloadedSegments = [];
            failedSegments = [];
            isDownloading = false;
            encryptionKey = null;
            encryptionIV = null;
            currentLocalFile = null;
            
            document.getElementById('m3u8Url').value = '';
            document.getElementById('ffmpegUrl').value = '';
            document.getElementById('localFile').value = '';
            document.getElementById('statsSection').classList.add('hidden');
            document.getElementById('progressBar').classList.add('hidden');
            document.getElementById('encryptionInfo').classList.add('hidden');
            document.getElementById('ffmpegCommand').classList.add('hidden');
            document.getElementById('logSection').classList.add('hidden');
            
            showAlert('已清空所有数据', 'info');
        }

        // 键盘快捷键
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 'Enter') {
                parseM3U8();
            } else if (e.ctrlKey && e.key === 'r') {
                e.preventDefault();
                retryFailedSegments();
            }
        });
    </script>
</body>
</html>